/*******************************************************************************
 * Copyright (c) 2018, 2019 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
package boost.runtimes.openliberty;

import static boost.common.config.ConfigConstants.*;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

import boost.common.BoostLoggerI;
import boost.common.config.BoostProperties;
import boost.common.utils.BoostUtil;
import net.wasdev.wlp.common.plugins.util.OSUtil;

/**
 * Create a Liberty server.xml
 *
 */
public class LibertyServerConfigGenerator {

    private final String serverPath;
    private final String libertyInstallPath;
    private final String encryptionType;

    private final BoostLoggerI logger;

    private Document serverXml;
    private Element featureManager;
    private Element serverRoot;
    private Element httpEndpoint;

    private Set<String> featuresAdded;

    private Properties bootstrapProperties;

    public LibertyServerConfigGenerator(String serverPath, String encryptionType, BoostLoggerI logger) throws ParserConfigurationException {

        this.serverPath = serverPath;
        this.libertyInstallPath = serverPath + "/../../.."; // Three directories
                                                            // back from
                                                            // 'wlp/usr/servers/BoostServer'
        this.encryptionType = encryptionType;
        this.logger = logger;

        generateServerXml();

        featuresAdded = new HashSet<String>();
        bootstrapProperties = new Properties();
    }

    private void generateServerXml() throws ParserConfigurationException {
        DocumentBuilder docBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();

        // Create top level server config element
        serverXml = docBuilder.newDocument();
        serverRoot = serverXml.createElement("server");
        serverRoot.setAttribute("description", "Liberty server generated by Liberty Boost");
        serverXml.appendChild(serverRoot);

        // Create featureManager config element
        featureManager = serverXml.createElement(FEATURE_MANAGER);
        serverRoot.appendChild(featureManager);

        // Create httpEndpoint config element
        httpEndpoint = serverXml.createElement(HTTP_ENDPOINT);
        httpEndpoint.setAttribute("id", DEFAULT_HTTP_ENDPOINT);
        serverRoot.appendChild(httpEndpoint);
    }

    /**
     * Add a Liberty feature to the server configuration
     *
     */
    public void addFeature(String featureName) {
        if (!featuresAdded.contains(featureName)) {
            Element feature = serverXml.createElement(FEATURE);
            feature.appendChild(serverXml.createTextNode(featureName));
            featureManager.appendChild(feature);
            featuresAdded.add(featureName);
        }
    }

    /**
     * Add a list of features to the server configuration
     *
     */
    public void addFeatures(List<String> features) {

        for (String featureName : features) {
            addFeature(featureName);
        }
    }

    /**
     * Write the server.xml and bootstrap.properties to the server config
     * directory
     *
     * @throws TransformerException
     * @throws IOException
     */
    public void writeToServer() throws TransformerException, IOException {
        // Replace auto-generated server.xml
        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        Transformer transformer = transformerFactory.newTransformer();
        transformer.setOutputProperty(OutputKeys.METHOD, "xml");
        transformer.setOutputProperty(OutputKeys.INDENT, "yes");
        transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4");
        transformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8");
        DOMSource source = new DOMSource(serverXml);
        StreamResult result = new StreamResult(new File(serverPath + "/server.xml"));
        transformer.transform(source, result);

        // Generate bootstrap.properties
        if (!bootstrapProperties.isEmpty()) {

            OutputStream output = null;
            try {
                output = new FileOutputStream(serverPath + "/bootstrap.properties");
                bootstrapProperties.store(output, null);
            } finally {
                if (output != null) {
                    output.close();
                }
            }
        }

        // Try setting all bootstrap properties to system properties for test
        // purposes
        for (String key : bootstrapProperties.stringPropertyNames()) {
            System.setProperty(key, bootstrapProperties.getProperty(key));
        }
    }

    public void addBootstrapProperties(Properties properties) throws IOException {

        if (properties != null) {
            for (String key : properties.stringPropertyNames()) {
                String value = properties.getProperty(key);

                addBoostrapProperty(key, value);
            }
        }
    }

    private void addBoostrapProperty(String key, String value) throws IOException {

        // Using this to hold the properties we want to encrypt and the type of
        // encryption we want to use
        Map<String, String> propertiesToEncrypt = BoostProperties.getPropertiesToEncrypt();

        if (propertiesToEncrypt.containsKey(key) && value != null && !value.equals("")) {
            value = encrypt(value);
        }

        bootstrapProperties.put(key, value);
    }

    public void addKeystore(Map<String, String> keystoreProps, Map<String, String> keyProps) {
        Element keystore = serverXml.createElement(KEYSTORE);
        keystore.setAttribute("id", DEFAULT_KEYSTORE);

        for (String key : keystoreProps.keySet()) {
            keystore.setAttribute(key, keystoreProps.get(key));
        }

        if (!keyProps.isEmpty()) {
            Element keyEntry = serverXml.createElement(KEY_ENTRY);

            for (String key : keyProps.keySet()) {
                keyEntry.setAttribute(key, keyProps.get(key));
            }

            keystore.appendChild(keyEntry);
        }

        serverRoot.appendChild(keystore);
    }

    public void addApplication(String appName) {
        Element appCfg = serverXml.createElement(APPLICATION);
        appCfg.setAttribute(CONTEXT_ROOT, "/");
        appCfg.setAttribute(LOCATION, appName + "." + WAR_PKG_TYPE);
        appCfg.setAttribute(TYPE, WAR_PKG_TYPE);
        serverRoot.appendChild(appCfg);

    }

    public void addHostname(String hostname) throws Exception {
        httpEndpoint.setAttribute("host", BoostUtil.makeVariable(BoostProperties.ENDPOINT_HOST));

        addBoostrapProperty(BoostProperties.ENDPOINT_HOST, hostname);
    }

    public void addHttpPort(String httpPort) throws Exception {
        httpEndpoint.setAttribute("httpPort", BoostUtil.makeVariable(BoostProperties.ENDPOINT_HTTP_PORT));

        addBoostrapProperty(BoostProperties.ENDPOINT_HTTP_PORT, httpPort);
    }

    public void addHttpsPort(String httpsPort) throws Exception {
        httpEndpoint.setAttribute("httpsPort", BoostUtil.makeVariable(BoostProperties.ENDPOINT_HTTPS_PORT));

        addBoostrapProperty(BoostProperties.ENDPOINT_HTTPS_PORT, httpsPort);
    }

    public Document getServerXmlDoc() {
        return serverXml;
    }
    
    private String getSecurityUtilCmd(String libertyInstallPath) {
        if (OSUtil.isWindows()) {
            return libertyInstallPath + "/bin/securityUtility.bat";
        } else {
            return libertyInstallPath + "/bin/securityUtility";
        }
    }

    private String encrypt(String property) throws IOException {
        //Won't encode the property if it contains the aes flag
        if (!isEncoded(property)) {
            Runtime rt = Runtime.getRuntime();
            List<String> commands = new ArrayList<String>();

            commands.add(getSecurityUtilCmd(libertyInstallPath));
            commands.add("encode");
            commands.add(property);

            if(encryptionType != null && !encryptionType.equals("")) {
                commands.add("--encoding=" + encryptionType);
            } else {
                commands.add("--encoding=aes");
            }

            String encryptionKey = BoostProperties.getPropertiesToEncrypt().get(property);
            if(encryptionKey != null && !encryptionKey.equals("")) {
                commands.add("--key=" + encryptionKey);
            }

            Process proc = rt.exec(commands.toArray(new String[0]));

            BufferedReader stdInput = new BufferedReader(new InputStreamReader(proc.getInputStream()));

            BufferedReader stdError = new BufferedReader(new InputStreamReader(proc.getErrorStream()));

            String s = null;

            StringBuilder out = new StringBuilder();
            while ((s = stdInput.readLine()) != null) {
                out.append(s);
            }

            StringBuilder error = new StringBuilder();
            while ((s = stdError.readLine()) != null) {
                error.append(s + "\n");
            }

            if (error.length() != 0) {
                throw new IOException("Password encryption failed: " + error);
            }

            return out.toString();
        }
        return property;
    }

    public boolean isEncoded(String property) {
        return property.contains("{aes}") || property.contains("{hash}") || property.contains("{xor}");
    }

}
